<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <title>STAGE - Quick Geometry Viewer</title>
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <script type="text/javascript" src="libs/d3.min.js"></script>
        <script type="text/javascript" src="http://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.3/leaflet.js"></script>
        <link rel="stylesheet" href="http://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.3/leaflet.css" />
        <script type='text/javascript' src='libs/jquery.min.js'></script>
        <style>
            .map {
                border-style: solid;
                border-width: 1px;
                border-color: #ccc;
            }
        </style>
    </head>

    <body>
        <div id="map"></div>
        <script>
            var width = Math.max(960, window.innerWidth) - 30,
                    height = Math.max(500, window.innerHeight) - 30;
            var map = void 0;
            var mapData = void 0;
            var leafletMap;
            var mapnik;
            var dataG;
            var lastC = 1;

//            loadScript();
            function loadScript() {

                var body = d3.select("body");
                body.select("#map").style("width", width + "px").style("height", height + "px");
                leafletMap = L.map('map');
                mapnik = L.tileLayer('http://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                    attribution: '&copy; <a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a>',
                    maxZoom: 25,
                    maxNativeZoom: 18
                });
                var esri_world = L.tileLayer('http://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
                    attribution: 'Tiles &copy; Esri',
                    maxZoom: 25,
                    maxNativeZoom: 18
                });
                var baseMaps = {
                    "mapnik": mapnik,
                    "esri_world": esri_world,
                };
                L.control.layers(baseMaps).addTo(leafletMap);
                leafletMap.setView([0.0, 0.0], 2);
                leafletMap._initPathRoot();
                leafletMap.on('moveend', function () {
                    checkData(false, lastC);
                });

                var mapSvg = d3.select("#map").select("svg");
                dataG = mapSvg.append("g");

//                d3.json("geoms.json", function (data) {

                checkData(true, lastC);
                mapnik.addTo(leafletMap);


//                });
            }

            function project(x, y) {
                var point = leafletMap.latLngToLayerPoint(new L.LatLng(y, x));
                return point;
            }

            function checkData(fitData, colortab) {
                lastC = colortab;
                var zoom = leafletMap.getZoom();

                var type = 1;
                if (zoom > 16) {
                    type = 2;
                }
                if (zoom > 20) {
                    type = 3;
                }

                var bb = leafletMap.getBounds();

                var w = bb.getWest();
                var e = bb.getEast();
                var s = bb.getSouth();
                var n = bb.getNorth();


                // 1=overview, 2=cells, 3=points
                var dataStr = getJsonData(type, s, n, w, e, zoom);
                if (!dataStr)
                    return;
                var json = JSON.parse(dataStr);

                var minVal = json.vmin;
                var maxVal = json.vmax;

                var delta = (maxVal - minVal) / 4;
                var colorScale;
                if (colortab === 1) {
                    colorScale = d3.scale.linear()
                            .domain(
                                    [
                                        minVal,
                                        minVal + delta,
                                        minVal + 2 * delta,
                                        minVal + 3 * delta,
                                        maxVal
                                    ]
                                    )
                            .range(
                                    [
                                        d3.rgb(0, 191, 191),
                                        d3.rgb(255, 255, 0),
                                        d3.rgb(255, 127, 0),
                                        d3.rgb(191, 127, 63),
                                        d3.rgb(20, 21, 20)
                                    ]
                                    );
                } else {
                    colorScale = d3.scale.linear() // <-A
                            .domain(
                                    [
                                        minVal,
                                        minVal + delta,
                                        minVal + 2 * delta,
                                        minVal + 3 * delta,
                                        maxVal
                                    ]
                                    )
                            .range(
                                    [
                                        d3.rgb(255, 255, 0),
                                        d3.rgb(0, 255, 0),
                                        d3.rgb(0, 0, 255),
                                        d3.rgb(255, 0, 255),
                                        d3.rgb(255, 0, 0)
                                    ]
                                    );
                }


                // DATA JOIN
                // Join new data with old elements, if any.
                var rects = dataG.selectAll("polygon")
                        .data(json.data);

                // UPDATE
                // Update old elements as needed.
                rects.attr("points", function (d) {
                    if (type === 1 || type === 2) {
                        var str = "";
                        var p = project(d.x1, d.y1);
                        str += p.x + "," + p.y;
                        p = project(d.x2, d.y2);
                        str += " " + p.x + "," + p.y;
                        p = project(d.x3, d.y3);
                        str += " " + p.x + "," + p.y;
                        p = project(d.x4, d.y4);
                        str += " " + p.x + "," + p.y;
                        return str;
                    } else {
                        var dx = 3;
                        var p = project(d.x1, d.y1);
                        var str = (p.x - dx) + "," + (p.y - dx);
                        str += " " + (p.x - dx) + "," + (p.y + dx);
                        str += " " + (p.x + dx) + "," + (p.y + dx);
                        str += " " + (p.x + dx) + "," + (p.y - dx);
                        return str;
                    }
                })
                        .style("stroke", function (d) {
                            if (type === 1) {
                                return colorScale(d.v);
                            }
                        })
                        .style("stroke-width", function (d) {
                            if (type === 1) {
                                return 2;
                            }
                        })
                        .style("fill", function (d) {
                            return colorScale(d.v);
                        })
                        .style("fill-opacity", function (d) {
                            if (type === 1) {
                                return 0;
                            }
                            return 0.7;
                        });

                rects.select("title").text(function (d) {
                    if (d.l)
                        return d.l;
                    return d.v
                });


                // ENTER
                // Create new elements as needed.
                rects.enter().append("polygon")
                        .attr("points", function (d) {
                            if (type === 1 || type === 2) {
                                var str = "";
                                var p = project(d.x1, d.y1);
                                str += p.x + "," + p.y;
                                p = project(d.x2, d.y2);
                                str += " " + p.x + "," + p.y;
                                p = project(d.x3, d.y3);
                                str += " " + p.x + "," + p.y;
                                p = project(d.x4, d.y4);
                                str += " " + p.x + "," + p.y;
                                return str;
                            } else {
                                var dx = 2;
                                var p = project(d.x1, d.y1);
                                var str = (p.x - dx) + "," + (p.y - dx);
                                str += " " + (p.x - dx) + "," + (p.y + dx);
                                str += " " + (p.x + dx) + "," + (p.y + dx);
                                str += " " + (p.x + dx) + "," + (p.y - dx);
                                return str;
                            }
                        })
                        .style("stroke", function (d) {
                            if (type === 1) {
                                return colorScale(d.v);
                            }
                        })
                        .style("stroke-width", function (d) {
                            if (type === 1) {
                                return 2;
                            }
                        })
                        .style("fill", function (d) {
                            return colorScale(d.v);
                        })
                        .style("fill-opacity", function (d) {
                            if (type === 1) {
                                return 0;
                            }
                            return 0.7;
                        })
                        .append("svg:title")
                        .text(function (d) {
                            if (d.l)
                                return d.l;
                            return d.v;
                        });

                rects.exit().remove();

                if (fitData && json.ymin) {
                    var southWest = L.latLng(json.ymin, json.xmin),
                            northEast = L.latLng(json.ymax, json.xmax),
                            fitBounds = L.latLngBounds(southWest, northEast);
//                    leafletMap.fitBounds([
//                        [json.ymin, json.xmin],
//                        [json.ymax, json.xmax]
//                    ]);
//                    fitBounds = gjson.getBounds();
                    leafletMap.fitBounds(fitBounds);
                }
            }

        </script>
    </body>